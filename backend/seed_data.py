"""Seed script for Netherlands riding content.

Populates Firestore with curated riding locations, biker-friendly restaurants,
and hotels for motorcycle riders in the Netherlands.

The script uses Claude Sonnet to generate compelling descriptions and Google
Street View Static API for scenic road photos.

Usage:
    # Set environment variables
    export ANTHROPIC_API_KEY=sk-ant-...
    export GOOGLE_MAPS_API_KEY=AIza...

    # Provide Firebase credentials (one of):
    #   a) GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json
    #   b) Place service account key at backend/firebase-sa-key.json

    python seed_data.py

    # Optional: clear existing data first
    python seed_data.py --clear
"""

import argparse
import json
import logging
import os
import sys

import anthropic
import firebase_admin
from firebase_admin import credentials, firestore
import googlemaps

logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

CLAUDE_MODEL = "claude-sonnet-4-6"
STREET_VIEW_SIZE = "600x400"
STREET_VIEW_FOV = 90
STREET_VIEW_PITCH = 5
COUNTRY = "nl"

# ---------------------------------------------------------------------------
# Netherlands riding regions — curated seed data
#
# Each region has known-good coordinates for scenic roads, a center point,
# and approximate bounds.  Descriptions are generated by Claude.
# ---------------------------------------------------------------------------

REGIONS = [
    {
        "name": "South Limburg",
        "center": {"lat": 50.84, "lng": 5.87},
        "bounds_ne": {"lat": 50.92, "lng": 6.08},
        "bounds_sw": {"lat": 50.73, "lng": 5.70},
        "tags": ["twisty", "hills", "scenic", "valleys"],
        "scenery_type": "mountains",
        "scenic_roads": [
            # Cauberg climb road — famous cycling/riding hill
            {"lat": 50.8622, "lng": 5.8268, "heading": 150},
            # N278 through Gulpdal valley — winding road between hills
            {"lat": 50.7952, "lng": 5.8856, "heading": 210},
            # Road descending from Vijlenerbos forest
            {"lat": 50.8178, "lng": 5.9647, "heading": 320},
            # Climbing road near Epen — tree-lined valley road
            {"lat": 50.7735, "lng": 5.9118, "heading": 140},
            # Winding road south of Vaals toward Drielandenpunt
            {"lat": 50.7640, "lng": 5.9750, "heading": 200},
            # N595 scenic road through Geuldal
            {"lat": 50.8340, "lng": 5.9080, "heading": 100},
        ],
    },
    {
        "name": "Veluwe",
        "center": {"lat": 52.25, "lng": 5.85},
        "bounds_ne": {"lat": 52.45, "lng": 6.10},
        "bounds_sw": {"lat": 52.05, "lng": 5.60},
        "tags": ["forests", "heathland", "sweeping", "nature"],
        "scenery_type": "forests",
        "scenic_roads": [
            # N-road near Beekbergen — confirmed coverage, forest road
            {"lat": 52.1850, "lng": 5.9240, "heading": 340},
            # Road near Nunspeet — confirmed coverage, Veluwe edge
            {"lat": 52.3350, "lng": 5.8250, "heading": 160},
            # N224 near Ede — confirmed coverage, forest corridor
            {"lat": 52.1200, "lng": 5.7950, "heading": 75},
            # Road through central Veluwe — confirmed coverage
            {"lat": 52.2600, "lng": 5.8550, "heading": 200},
            # Road near Wageningen — confirmed coverage, Veluwe south
            {"lat": 52.1000, "lng": 5.7300, "heading": 30},
            # Posbank area — may have limited coverage
            {"lat": 52.0845, "lng": 5.9730, "heading": 30},
        ],
    },
    {
        "name": "Zeeland Coast",
        "center": {"lat": 51.50, "lng": 3.80},
        "bounds_ne": {"lat": 51.75, "lng": 4.20},
        "bounds_sw": {"lat": 51.30, "lng": 3.40},
        "tags": ["coastal", "dykes", "flat", "wind", "bridges"],
        "scenery_type": "coastline",
        "scenic_roads": [
            # N57 Brouwersdam — straight road over the dam, sea on both sides
            {"lat": 51.7480, "lng": 3.8680, "heading": 210},
            # Oosterscheldekering — storm surge barrier road
            {"lat": 51.6280, "lng": 3.7050, "heading": 250},
            # N287 coastal dyke road near Vrouwenpolder
            {"lat": 51.5900, "lng": 3.5950, "heading": 310},
            # Westkapelle sea dyke — open ocean road
            {"lat": 51.5270, "lng": 3.4420, "heading": 350},
            # Veerse Dam road — lake on both sides
            {"lat": 51.5620, "lng": 3.6540, "heading": 90},
            # N256 Zeelandbrug approach — bridge over Oosterschelde
            {"lat": 51.6350, "lng": 3.9150, "heading": 310},
        ],
    },
    {
        "name": "Drenthe",
        "center": {"lat": 52.90, "lng": 6.60},
        "bounds_ne": {"lat": 53.10, "lng": 6.90},
        "bounds_sw": {"lat": 52.70, "lng": 6.30},
        "tags": ["quiet", "forests", "heathland", "historic"],
        "scenery_type": "forests",
        "scenic_roads": [
            # Tree-lined road through Dwingelderveld national park
            {"lat": 52.7950, "lng": 6.3800, "heading": 170},
            # N371 road near Dwingeloo — birch-lined avenue
            {"lat": 52.8380, "lng": 6.3650, "heading": 350},
            # Hondsrug ridge road near Borger — open heathland
            {"lat": 52.9200, "lng": 6.7950, "heading": 160},
            # Forest road near Gasselte — quiet pine woods
            {"lat": 52.9620, "lng": 6.7800, "heading": 240},
            # Road through Drents-Friese Wold forest
            {"lat": 52.9050, "lng": 6.2800, "heading": 60},
            # Balloërveld heathland road — open landscape
            {"lat": 53.0150, "lng": 6.6350, "heading": 120},
        ],
    },
    {
        "name": "Achterhoek",
        "center": {"lat": 52.00, "lng": 6.45},
        "bounds_ne": {"lat": 52.15, "lng": 6.75},
        "bounds_sw": {"lat": 51.85, "lng": 6.15},
        "tags": ["rolling", "quiet", "countryside", "backroads"],
        "scenery_type": "mixed",
        "scenic_roads": [
            # Backroad near Bronckhorst — NL's smallest town, countryside
            {"lat": 52.0700, "lng": 6.2300, "heading": 110},
            # Rolling farmland road near Winterswijk — bocage landscape
            {"lat": 51.9650, "lng": 6.6800, "heading": 320},
            # Wooded lane near Ruurlo — estate roads
            {"lat": 52.0850, "lng": 6.4500, "heading": 200},
            # Road through Slangenburg forest — tree canopy
            {"lat": 51.9320, "lng": 6.2650, "heading": 70},
            # Countryside near Lochem — gentle rolling hills
            {"lat": 52.1600, "lng": 6.4100, "heading": 150},
            # Backroad near Borculo — classic Dutch farmland
            {"lat": 52.1180, "lng": 6.5250, "heading": 280},
        ],
    },
    {
        "name": "Utrechtse Heuvelrug",
        "center": {"lat": 52.08, "lng": 5.35},
        "bounds_ne": {"lat": 52.18, "lng": 5.55},
        "bounds_sw": {"lat": 51.98, "lng": 5.15},
        "tags": ["wooded", "hills", "estates", "scenic"],
        "scenery_type": "forests",
        "scenic_roads": [
            # N225 Amerongen — winding road through wooded hills
            {"lat": 52.0020, "lng": 5.4620, "heading": 260},
            # Forest road between Doorn and Driebergen — beech canopy
            {"lat": 52.0440, "lng": 5.3480, "heading": 130},
            # Lage Vuursche road — wooded estate lanes
            {"lat": 52.1750, "lng": 5.2350, "heading": 340},
            # N227 near Rhenen — views over Rhine valley
            {"lat": 51.9650, "lng": 5.5650, "heading": 80},
            # Forest road near Austerlitz — tall pines
            {"lat": 52.0850, "lng": 5.3100, "heading": 200},
            # Winding road through Amelisweerd — canopy road
            {"lat": 52.0700, "lng": 5.1750, "heading": 160},
        ],
    },
    {
        "name": "Overijssel Salland",
        "center": {"lat": 52.45, "lng": 6.30},
        "bounds_ne": {"lat": 52.60, "lng": 6.55},
        "bounds_sw": {"lat": 52.30, "lng": 6.05},
        "tags": ["rolling", "rivers", "farmland", "quiet"],
        "scenery_type": "mixed",
        "scenic_roads": [
            # Road near Raalte — confirmed coverage, Salland countryside
            {"lat": 52.5000, "lng": 6.3000, "heading": 250},
            # N348 near Ommen — winding road along Vecht river
            {"lat": 52.5250, "lng": 6.4250, "heading": 160},
            # Road along IJssel river near Deventer — open meadow views
            {"lat": 52.2780, "lng": 6.1250, "heading": 340},
            # Sallandse Heuvelrug — tree-lined national park road
            {"lat": 52.4530, "lng": 6.3250, "heading": 200},
            # Forest road Hellendoorn — wooded ridge
            {"lat": 52.3950, "lng": 6.4600, "heading": 30},
            # Backroad near Dalfsen — classic Overijssel countryside
            {"lat": 52.5050, "lng": 6.2850, "heading": 250},
        ],
    },
    {
        "name": "Noord-Brabant Kempen",
        "center": {"lat": 51.45, "lng": 5.30},
        "bounds_ne": {"lat": 51.60, "lng": 5.60},
        "bounds_sw": {"lat": 51.30, "lng": 5.00},
        "tags": ["forests", "heathland", "quiet", "sandy"],
        "scenery_type": "forests",
        "scenic_roads": [
            # Road near Loon op Zand — confirmed coverage, forest edge
            {"lat": 51.6300, "lng": 5.0800, "heading": 300},
            # Road near Eersel — confirmed coverage, Kempen countryside
            {"lat": 51.4300, "lng": 5.3500, "heading": 140},
            # Road near Reusel — confirmed coverage, forested area
            {"lat": 51.3600, "lng": 5.3000, "heading": 190},
            # Oisterwijk forest lane — ancient oak-lined road
            {"lat": 51.5660, "lng": 5.2050, "heading": 220},
            # Forest road near Bladel — Kempen pine woods
            {"lat": 51.3680, "lng": 5.2200, "heading": 140},
            # Strabrechtse Heide road — open heathland
            {"lat": 51.3950, "lng": 5.6150, "heading": 80},
        ],
    },
]


# ---------------------------------------------------------------------------
# Claude description generation
# ---------------------------------------------------------------------------


def _generate_descriptions(client: anthropic.Anthropic) -> dict:
    """Use Claude to generate descriptions for all regions, restaurants, and hotels."""

    region_names = [r["name"] for r in REGIONS]
    region_list = "\n".join(f"- {name}" for name in region_names)

    prompt = f"""You are an expert on motorcycle touring in the Netherlands. Generate curated content for a motorcycle navigation app.

For each of these riding regions, provide:
1. A compelling 2-3 sentence description of why this area is great for motorcyclists (road character, scenery, what makes it special)
2. Two well-known, real restaurants in or near the region that would be great stops for motorcycle breakfast/lunch runs. These MUST be real, existing establishments.
3. One well-known, real hotel or B&B in or near the region suitable for an overnight motorcycle trip. This MUST be a real, existing establishment.

Regions:
{region_list}

For each restaurant include: name, a 1-2 sentence description of why bikers would love it, approximate latitude/longitude, cuisine type, and price range (€, €€, or €€€).

For each hotel include: name, a 1-2 sentence description, approximate latitude/longitude, price range, and biker-friendly amenities (e.g., secure parking, drying room, garage).

Respond in this exact JSON format:
{{
  "regions": [
    {{
      "name": "Region Name",
      "description": "Why this area is amazing for motorcyclists...",
      "restaurants": [
        {{
          "name": "Restaurant Name",
          "description": "Why bikers love this place...",
          "lat": 50.85,
          "lng": 5.90,
          "cuisine_type": "Dutch",
          "price_range": "€€"
        }}
      ],
      "hotels": [
        {{
          "name": "Hotel Name",
          "description": "Why this is great for an overnight bike trip...",
          "lat": 50.84,
          "lng": 5.88,
          "price_range": "€€",
          "biker_amenities": ["secure parking", "drying room"]
        }}
      ]
    }}
  ]
}}

Important: Only include REAL establishments that actually exist. Use accurate coordinates."""

    logger.info("Generating descriptions with Claude Sonnet...")
    response = client.messages.create(
        model=CLAUDE_MODEL,
        max_tokens=8192,
        messages=[{"role": "user", "content": prompt}],
    )

    # Extract JSON from response
    text = response.content[0].text
    # Find JSON block (may be wrapped in ```json ... ```)
    if "```json" in text:
        text = text.split("```json")[1].split("```")[0]
    elif "```" in text:
        text = text.split("```")[1].split("```")[0]

    return json.loads(text)


# ---------------------------------------------------------------------------
# Google Street View photo URLs
# ---------------------------------------------------------------------------


MAX_PHOTOS_PER_REGION = 3


def _street_view_url(lat: float, lng: float, heading: int, api_key: str) -> str:
    """Build a Google Street View Static API URL.

    Uses the actual panorama location (from metadata snapping) and a
    source=outdoor filter for road-level imagery.
    """
    return (
        f"https://maps.googleapis.com/maps/api/streetview"
        f"?size={STREET_VIEW_SIZE}"
        f"&location={lat},{lng}"
        f"&heading={heading}"
        f"&fov={STREET_VIEW_FOV}"
        f"&pitch={STREET_VIEW_PITCH}"
        f"&key={api_key}"
    )


def _get_street_view_metadata(
    lat: float, lng: float, api_key: str,
) -> dict | None:
    """Fetch Street View metadata for the nearest panorama.

    Returns the metadata dict if an outdoor panorama exists within range,
    otherwise None. The metadata includes the snapped panorama location.
    """
    import requests as req

    url = (
        f"https://maps.googleapis.com/maps/api/streetview/metadata"
        f"?location={lat},{lng}"
        f"&key={api_key}"
    )
    resp = req.get(url, timeout=10)
    if resp.status_code != 200:
        return None

    data = resp.json()
    if data.get("status") != "OK":
        return None

    return data


def _generate_photo_urls(region: dict, api_key: str) -> list[str]:
    """Generate the best Street View photo URLs for a region.

    Tries all scenic road candidates, checks for outdoor panorama
    coverage, uses the snapped panorama location for accuracy, and
    returns up to MAX_PHOTOS_PER_REGION URLs.
    """
    candidates = []
    seen_pano_ids: set[str] = set()

    for road in region.get("scenic_roads", []):
        meta = _get_street_view_metadata(road["lat"], road["lng"], api_key)
        if meta is None:
            continue

        # Skip duplicate panoramas (nearby coords can snap to the same one).
        pano_id = meta.get("pano_id", "")
        if pano_id in seen_pano_ids:
            continue
        seen_pano_ids.add(pano_id)

        # Use the snapped panorama location for the final URL — this is
        # where the imagery actually exists (vs our approximate coords).
        snapped = meta.get("location", {})
        snapped_lat = snapped.get("lat", road["lat"])
        snapped_lng = snapped.get("lng", road["lng"])

        url = _street_view_url(
            snapped_lat, snapped_lng, road["heading"], api_key,
        )
        candidates.append(url)

        if len(candidates) >= MAX_PHOTOS_PER_REGION:
            break

    return candidates


# ---------------------------------------------------------------------------
# Firestore write operations
# ---------------------------------------------------------------------------


def _clear_collections(db: firestore.firestore.Client) -> None:
    """Delete all documents in the riding content collections."""
    for collection in ("riding_locations", "restaurants", "hotels"):
        logger.info("Clearing %s...", collection)
        docs = db.collection(collection).stream()
        for doc in docs:
            doc.reference.delete()


def _write_to_firestore(
    db: firestore.firestore.Client,
    descriptions: dict,
    api_key: str,
) -> None:
    """Write all curated data to Firestore."""
    regions_data = descriptions.get("regions", [])

    for order, region_seed in enumerate(REGIONS):
        # Match Claude's description data to our seed region
        region_desc = next(
            (r for r in regions_data if r["name"] == region_seed["name"]),
            None,
        )
        if not region_desc:
            logger.warning("No description found for %s, skipping", region_seed["name"])
            continue

        # Generate Street View photos
        photo_urls = _generate_photo_urls(region_seed, api_key)
        logger.info(
            "  %s: %d Street View photos", region_seed["name"], len(photo_urls),
        )

        # Write riding location
        location_ref = db.collection("riding_locations").document()
        location_id = location_ref.id
        location_data = {
            "country": COUNTRY,
            "name": region_seed["name"],
            "description": region_desc["description"],
            "center": firestore.firestore.GeoPoint(
                region_seed["center"]["lat"], region_seed["center"]["lng"],
            ),
            "bounds_ne": firestore.firestore.GeoPoint(
                region_seed["bounds_ne"]["lat"], region_seed["bounds_ne"]["lng"],
            ),
            "bounds_sw": firestore.firestore.GeoPoint(
                region_seed["bounds_sw"]["lat"], region_seed["bounds_sw"]["lng"],
            ),
            "photo_urls": photo_urls,
            "tags": region_seed["tags"],
            "scenery_type": region_seed["scenery_type"],
            "order": order,
        }
        location_ref.set(location_data)
        logger.info("  Wrote location: %s", region_seed["name"])

        # Write restaurants
        for r_order, restaurant in enumerate(region_desc.get("restaurants", [])):
            rest_ref = db.collection("restaurants").document()
            rest_data = {
                "country": COUNTRY,
                "name": restaurant["name"],
                "description": restaurant["description"],
                "location": firestore.firestore.GeoPoint(
                    restaurant["lat"], restaurant["lng"],
                ),
                "riding_location_id": location_id,
                "riding_location_name": region_seed["name"],
                "photo_urls": [],  # Restaurants don't get Street View by default
                "cuisine_type": restaurant.get("cuisine_type", "Mixed"),
                "price_range": restaurant.get("price_range", "€€"),
                "google_place_id": "",
                "order": order * 10 + r_order,
            }
            rest_ref.set(rest_data)
            logger.info("    Wrote restaurant: %s", restaurant["name"])

        # Write hotels
        for h_order, hotel in enumerate(region_desc.get("hotels", [])):
            hotel_ref = db.collection("hotels").document()
            hotel_data = {
                "country": COUNTRY,
                "name": hotel["name"],
                "description": hotel["description"],
                "location": firestore.firestore.GeoPoint(
                    hotel["lat"], hotel["lng"],
                ),
                "riding_location_id": location_id,
                "riding_location_name": region_seed["name"],
                "photo_urls": [],
                "price_range": hotel.get("price_range", "€€"),
                "biker_amenities": hotel.get("biker_amenities", []),
                "google_place_id": "",
                "order": order * 10 + h_order,
            }
            hotel_ref.set(hotel_data)
            logger.info("    Wrote hotel: %s", hotel["name"])


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------


def main() -> None:
    parser = argparse.ArgumentParser(description="Seed Netherlands riding content")
    parser.add_argument(
        "--clear", action="store_true", help="Clear existing data before seeding",
    )
    args = parser.parse_args()

    # Validate environment
    anthropic_key = os.environ.get("ANTHROPIC_API_KEY")
    maps_key = os.environ.get("GOOGLE_MAPS_API_KEY")
    if not anthropic_key:
        logger.error("ANTHROPIC_API_KEY not set")
        sys.exit(1)
    if not maps_key:
        logger.error("GOOGLE_MAPS_API_KEY not set")
        sys.exit(1)

    # Initialise Firebase Admin
    sa_path = os.environ.get(
        "GOOGLE_APPLICATION_CREDENTIALS",
        os.path.join(os.path.dirname(__file__), "firebase-sa-key.json"),
    )
    if os.path.exists(sa_path):
        cred = credentials.Certificate(sa_path)
        firebase_admin.initialize_app(cred)
        logger.info("Firebase initialised with service account: %s", sa_path)
    else:
        # Try Application Default Credentials (e.g. on GCP)
        firebase_admin.initialize_app()
        logger.info("Firebase initialised with Application Default Credentials")

    db = firestore.client()

    if args.clear:
        _clear_collections(db)
        logger.info("Cleared existing data.")

    # Generate descriptions with Claude
    claude = anthropic.Anthropic(api_key=anthropic_key)
    descriptions = _generate_descriptions(claude)

    # Write to Firestore
    logger.info("Writing to Firestore...")
    _write_to_firestore(db, descriptions, maps_key)

    # Summary
    logger.info("Seed complete!")
    logger.info(
        "  %d riding locations, ~%d restaurants, ~%d hotels",
        len(REGIONS),
        len(REGIONS) * 2,
        len(REGIONS),
    )


if __name__ == "__main__":
    main()
